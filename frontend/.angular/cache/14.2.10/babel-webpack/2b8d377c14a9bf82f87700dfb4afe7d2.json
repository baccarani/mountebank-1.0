{"ast":null,"code":"import { map } from \"rxjs/operators\";\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nexport let ImposterService = /*#__PURE__*/(() => {\n  class ImposterService {\n    constructor(http) {\n      this.http = http;\n      this.stubs = [];\n      this.imposterArray = null;\n      this.predicates = [];\n      this.subPredicates = [];\n      this.responses = [];\n    }\n\n    setOperator(operator) {\n      this.subPredicates.push(operator);\n    }\n\n    onGetPredicates() {\n      return this.predicates.slice();\n    }\n\n    onGetResponses() {\n      return this.responses.slice();\n    }\n\n    onAddPredicate({\n      operator,\n      method,\n      path,\n      newpath,\n      data,\n      newOperator,\n      query\n    }) {\n      this.predicates.push({\n        operator,\n        method,\n        path,\n        newpath,\n        data,\n        newOperator,\n        query\n      });\n    }\n\n    onAddResponse({\n      statusCode,\n      headers,\n      body\n    }) {\n      this.responses.push({\n        statusCode,\n        headers,\n        body\n      });\n    }\n\n    onResetPredicates() {\n      this.predicates = [];\n    }\n\n    onResetResponses() {\n      this.responses = [];\n    }\n\n    onDeletePredicate(index) {\n      this.predicates.splice(index, 1);\n    }\n\n    onDeleteResponse(index) {\n      this.responses.splice(index, 1);\n    }\n\n    onDeleteSubPredicate(index) {\n      this.subPredicates.splice(index, 1);\n    }\n\n    onGetImposter() {\n      let imposterArray$ = [];\n      this.imposterArray = this.http.get(`http://localhost:5000/imposters`).pipe(map(responseData => {\n        this.imposterArray = responseData;\n        this.imposterArray = this.imposterArray.imposters;\n\n        for (let index = 0; index < this.imposterArray.length; index++) {\n          this.http.get(`http://localhost:5000/imposters/${this.imposterArray[index].port}`).subscribe(data => {\n            imposterArray$.push(data);\n            imposterArray$.sort((a, b) => a.port - b.port);\n          });\n        }\n\n        return this.imposterArray = imposterArray$;\n      }));\n      return this.imposterArray;\n    }\n\n    onViewImposter(data) {\n      return this.http.get(`http://localhost:5000/imposters/${data}`);\n    }\n\n    onDeleteImposter(port, index) {\n      this.http.delete(`http://localhost:5000/imposters/${port}`).subscribe(data => {\n        this.imposterArray.splice(index, 1);\n      });\n    }\n\n    onCreateImposter(formValues) {\n      const predicates = this.predicates.map(predicate => {\n        const operator = predicate.operator;\n        const query = JSON.parse(predicate.query);\n        /**\n         * TODO: same for NOT opertor\n         */\n\n        let updatePath;\n\n        if (predicate.path == 'other') {\n          updatePath = predicate.newpath;\n        } else {\n          updatePath = predicate.path;\n        }\n\n        if (operator === \"or\" || operator === \"and\") {\n          return {\n            [operator]: [{\n              [predicate.newOperator]: {\n                method: predicate.method,\n                path: updatePath,\n                data: predicate.data\n              }\n            }]\n          };\n        } else {\n          return {\n            [operator]: {\n              method: predicate.method,\n              path: updatePath,\n              data: predicate.data,\n              query: query\n            }\n          };\n        }\n      });\n      const responses = this.responses.map(response => {\n        const statusCode = response.statusCode;\n        const headers = JSON.parse(response.headers);\n        const body = JSON.parse(response.body);\n        return {\n          is: {\n            statusCode: statusCode,\n            headers: headers,\n            body: body\n          }\n        };\n      });\n      const data = {\n        port: formValues.port,\n        protocol: formValues.protocol,\n        name: formValues.name,\n        stubs: [{\n          predicates: predicates,\n          responses: responses\n        }]\n      };\n      this.http.post(`http://localhost:5000/imposters`, data).subscribe(responseData => {\n        this.imposterArray.push(responseData);\n        this.imposterArray.sort((a, b) => {\n          return a.port - b.port;\n        });\n      }, error => {\n        console.error(error);\n      });\n    }\n\n    onExportImposter(data) {\n      const url = `http://localhost:5000/imposters/${data}/_postman`;\n      this.http.get(url, {\n        responseType: 'text'\n      }).subscribe(res => {\n        const blob = new Blob([res], {\n          type: 'application/json'\n        });\n        const url = window.URL.createObjectURL(blob);\n        const a = document.createElement('a');\n        a.href = url;\n        a.download = `imposter-${data}.json`;\n        window.URL.revokeObjectURL(url);\n      });\n    }\n\n  }\n\n  ImposterService.ɵfac = function ImposterService_Factory(t) {\n    return new (t || ImposterService)(i0.ɵɵinject(i1.HttpClient));\n  };\n\n  ImposterService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: ImposterService,\n    factory: ImposterService.ɵfac\n  });\n  return ImposterService;\n})();","map":null,"metadata":{},"sourceType":"module"}